Can we let Generator return a immovable type wrapped in a movable?
    This is simiar to our 2-stage logic.


This would allow locking a mutex across a suspend point
    This doesn't cause unsafety, but could lead to deadlocks

We might have to wait for more expressive non-movable types as it would avoid the pinning part of the generators.
    This will always be less expressive though, since it will start out paused with arguments (which are always movable)

Can we return FnOnce() -> Generator + ?Move instead?

Could we use a ?Move bound to indicate if the generator is non-movable?
    Could impl Future elide that if Future: ?Move?
    Can this work for closures too?

    Normally every type requires Move by default. We'll need to relax this in the return type?
    Would this have impact on other types? Yes impl Trait wouldn't be Move (The Trait itself would have a Move bound though)
    Can we relax this only for generators?

    No, the return type is always movable.

    Require that:
        Type parameters have Move by default
        Arguments and return types have ?Move by default
        Trait Self and type parameters have Move by default

        This does make sense, since only type parameters have bounds.

        Should `impl Trait` have Move or ?Move by default? Should it match Trait::Self (which would be ?Move by default)?
            I think this should be Move so impl Iterator and impl Generator is nice

Will ?Move require another Generator trait or can we still Have IntoGenreator::Into: Generator?

PROBLEM: References as hidden arguments cannot cross suspend points!

Can we write future combinators with ?Move types so we don't need the 2-stage PinGenerator plan?
    Probably, but we won't be able to collect futures into a Vec and select/join them

    We can use an arena to collect the futures.
        Could we also use Vec<Box<Future>>?

        Can we have Vec: T: ?Move and Box: T: ?Move and let the borrow be transitive? This is required here

            We could even have Vec<impl Future> then!

            PhantomData<T> should not require ?Move if T: ?Move
            How can we implement Move only if a type parameter does then?

            We can allow ?Move for Vec if we ban everything returning references, including Index

            Vec doesn't work. If we push another value on to it, it may relocate all the previous values. We may have observed those via Index
                Hm.. delete would also break things. It would be stack based with push and pop where pop would be banned (since it moves)

            We could have Vec like type which never relocates pushed entries

            Would we need to do anything for this to work?
                We need to have a T: Move bound on all function which actually move the values inside
                Index*/Deref* may have resulted in a borrow of them

    Check if the combinators require moves after poll()

Regular generators cannot contain non-movable types which lives across suspend points.
    Probably easy enough to ban them altogether.
        We don't need to. The borrow checker will catch any references to them across the suspend points.

Non-movable types can be returned from functions.
    How? return passes by ownership
        It can be allowed if we construct it inside the return statement.
            return NonMovable { .. }
            return create_non_movable()

    We can access the returned value with let v = &mut func();

Can we box these to do recursion and return Iterators?

Can we use `yield from box function_name()` to do recursion?

Which keyword / syntax to use for these?

Can we make for take PinIterator instead of IntoIterator?
    PinIterator is like IntoIterator, only the result is non-movable.
    Make for use IntoIterator inside movable generators

Name the wrappers type GeneratorType and PinGeneratorType?
    Should we have a wrapper type for the PinnedGen associated type?
        If so should we reuse GeneratorType or have a new one?

Should we make normal generators implement PinGenerator?
    Will we have a reason to inspect or require non-movable generators?


Use fn foo() => static impl Future for non-movable generators

Plan
    Use only yield and a way to access the argument

    3 RFCS:
        Movable generators
        Non-movable types
        Non-movable generators

    Look at placement syntax first
        We can just require a ?Move bound on the Data type parameters

Can we make initial suspend an option for non-movable generators?
